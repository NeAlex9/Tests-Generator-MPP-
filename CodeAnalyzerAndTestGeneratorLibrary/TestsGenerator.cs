using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using CodeAnalyzerAndTestGeneratorLibrary.FileHolder;
using CodeAnalyzerAndTestGeneratorLibrary.FileInfoStructure;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeAnalyzerAndTestGeneratorLibrary
{
    public static class TestsGenerator
    {
        private static readonly SyntaxToken PublicModifier;
        private static readonly SyntaxToken PrivateModifier;
        private static readonly SyntaxToken StaticKeyword;
        private static readonly TypeSyntax VoidReturnType;
        private static readonly AttributeSyntax SetupAttribute;
        private static readonly AttributeSyntax MethodAttribute;
        private static readonly AttributeSyntax SetUpAttribute;
        private static readonly AttributeSyntax ClassAttribute;
        private static readonly ExpressionStatementSyntax FailExpression;

        static TestsGenerator()
        {
            PublicModifier = SyntaxFactory.Token(SyntaxKind.PublicKeyword);
            PrivateModifier = SyntaxFactory.Token(SyntaxKind.PrivateKeyword);
            StaticKeyword = SyntaxFactory.Token(SyntaxKind.StaticKeyword);
            VoidReturnType = SyntaxFactory.ParseTypeName("void");
            SetupAttribute = SyntaxFactory.Attribute(SyntaxFactory.ParseName("SetUp"));
            MethodAttribute = SyntaxFactory.Attribute(SyntaxFactory.ParseName("Test"));
            ClassAttribute = SyntaxFactory.Attribute(SyntaxFactory.ParseName("TestFixture"));
            FailExpression = CreateFailExpression();
        }

        public static Dictionary<string, string> GenerateTests(FileInfo fileInfo)
        {
            var fileNameCode = new Dictionary<string, string>();
            foreach (var classInfo in fileInfo.Classes)
            {
                var classDeclaration = GenerateClass(classInfo);
                var compilationUnit = SyntaxFactory.CompilationUnit()
                    .AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System")))
                    .AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("NUnit.Framework")))
                    .AddMembers(classDeclaration);
                fileNameCode.Add(classInfo.ClassName + "Test",
                    compilationUnit.NormalizeWhitespace().ToFullString());
            }

            return fileNameCode;
        }

        private static ExpressionStatementSyntax CreateFailExpression()
        {
            return SyntaxFactory.ExpressionStatement(
                SyntaxFactory.InvocationExpression(
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            SyntaxFactory.IdentifierName("Assert"),
                            SyntaxFactory.IdentifierName("Fail")))
                    .WithArgumentList(
                        SyntaxFactory.ArgumentList(
                            SyntaxFactory.SingletonSeparatedList<ArgumentSyntax>(
                                SyntaxFactory.Argument(
                                    SyntaxFactory.LiteralExpression(
                                        SyntaxKind.StringLiteralExpression,
                                        SyntaxFactory.Literal("autogenerated")))))));
        }

        private static ConstructorInfo FindConstructorWithLargestNumOfParams(List<ConstructorInfo> constructors)
        {
            var constructor = constructors[0];
            foreach (var temp in constructors)
            {
                if (constructor.Parameters.Count < temp.Parameters.Count)
                {
                    constructor = temp;
                }
            }

            return constructor;
        }

        private static ClassDeclarationSyntax GenerateClass(ClassInfo classInfo)
        {
            var fields = new List<FieldDeclarationSyntax>();
            VariableDeclarationSyntax variable;
            if (classInfo.Constructors.Count > 0)
            {
                var constructor = FindConstructorWithLargestNumOfParams(classInfo.Constructors);
                foreach (var parameter in constructor.Parameters)
                {
                    if (parameter.Value[0] == 'I')
                    {
                        variable = GenerateVariable("_" + parameter.Key, $"Mock<{parameter.Value}>");
                        fields.Add(GenerateField(variable));
                    }
                }
            }

            variable = GenerateVariable("_" + classInfo.ClassName[0].ToString().ToLower() + classInfo.ClassName.Remove(0,1), classInfo.ClassName);
            fields.Add(GenerateField(variable));
            var methods = new List<MethodDeclarationSyntax>();
            foreach (var methodInfo in classInfo.Methods)
            {
                methods.Add(GenerateMethod(methodInfo));
            }

            return SyntaxFactory.ClassDeclaration(classInfo.ClassName)
                .AddMembers(fields.ToArray())
                .AddMembers(methods.ToArray())
                .AddAttributeLists(SyntaxFactory.AttributeList(SyntaxFactory.AttributeList().Attributes.Add(ClassAttribute)));
        }

        private static StatementSyntax GenerateBasesTypesAssignStatement(string varName, string varType)
        {
            return SyntaxFactory.ParseStatement(string.Format
            (
                "var {0} = default({1});",
                varName,
                varType
            ));
        }

        private static StatementSyntax GenerateCustomsTypesAssignStatement(string varName, string variable, string constructorName, string invokeArgs = "")
        {
            return SyntaxFactory.ParseStatement(string.Format
            (
                "{0} = new {1}{2};",
                varName,
                variable,
                $"({invokeArgs})"
            ));
        }

        private static VariableDeclarationSyntax GenerateVariable(string varName, string typeName)
        {
            return SyntaxFactory.VariableDeclaration(SyntaxFactory.ParseTypeName(typeName))
                .AddVariables(SyntaxFactory.VariableDeclarator(varName));
        }

        private static FieldDeclarationSyntax GenerateField(VariableDeclarationSyntax var)
        {
            return SyntaxFactory.FieldDeclaration(var)
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.PrivateKeyword));
        }

        private static List<StatementSyntax> GenerateArrangePart()
        {
            throw new NotImplementedException();
        }

        private static List<StatementSyntax> GenerateActPart()
        {
            throw new NotImplementedException();
        }

        private static List<StatementSyntax> GenerateAssertPart()
        {
            throw new NotImplementedException();
        }

        private static MethodDeclarationSyntax GenerateSetUpMethod(ConstructorInfo constructorInfo, Type className)
        {
            List<StatementSyntax> body = new List<StatementSyntax>();

            return SyntaxFactory.MethodDeclaration(VoidReturnType, "SetUp")
                .AddModifiers(PublicModifier)
                .AddAttributeLists(SyntaxFactory.AttributeList(SyntaxFactory.AttributeList().Attributes.Add(SetUpAttribute)))
                .WithBody(SyntaxFactory.Block(body)); ;
        }

        private static MethodDeclarationSyntax GenerateMethod(MethodInfo methodInfo)
        {
            List<StatementSyntax> actAssertBody = new List<StatementSyntax>();
            actAssertBody.Add(FailExpression);
            return SyntaxFactory.MethodDeclaration(VoidReturnType, methodInfo.Name)
                .AddModifiers(PublicModifier)
                .AddAttributeLists(SyntaxFactory.AttributeList(SyntaxFactory.AttributeList().Attributes.Add(MethodAttribute)))
                .WithBody(SyntaxFactory.Block(actAssertBody)); ;
        }
    }
}
