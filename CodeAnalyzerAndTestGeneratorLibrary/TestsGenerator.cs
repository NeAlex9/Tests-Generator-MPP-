using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using CodeAnalyzerAndTestGeneratorLibrary.FileHolder;
using CodeAnalyzerAndTestGeneratorLibrary.FileInfoStructure;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeAnalyzerAndTestGeneratorLibrary
{
    public static class TestsGenerator
    {
        private static readonly SyntaxToken PublicModifier;
        private static readonly SyntaxToken PrivateModifier;
        private static readonly SyntaxToken StaticKeyword;
        private static readonly TypeSyntax VoidReturnType;
        private static readonly AttributeSyntax SetupAttribute;
        private static readonly AttributeSyntax TestAttribute;
        private static readonly ExpressionStatementSyntax FailExpression;

        static TestsGenerator()
        {
            PublicModifier = SyntaxFactory.Token(SyntaxKind.PublicKeyword);
            PrivateModifier = SyntaxFactory.Token(SyntaxKind.PrivateKeyword);
            StaticKeyword = SyntaxFactory.Token(SyntaxKind.StaticKeyword);
            VoidReturnType = SyntaxFactory.ParseTypeName("void");
            SetupAttribute = SyntaxFactory.Attribute(SyntaxFactory.ParseName("SetUp"));
            TestAttribute = SyntaxFactory.Attribute(SyntaxFactory.ParseName("Test"));
            FailExpression = CreateFailExpression();
        }

        public static Dictionary<string, string> GenerateTests(FileInfo fileInfo)
        {
            var fileNameCode = new Dictionary<string, string>();
            foreach (var classInfo in fileInfo.Classes)
            {
                var classDeclaration = GenerateClass(classInfo);
                var compilationUnit = SyntaxFactory.CompilationUnit()
                    .AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System")))
                    .AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("NUnit.Framework")))
                    .AddMembers(classDeclaration);
                fileNameCode.Add(classInfo.ClassName + "Test",
                    compilationUnit.NormalizeWhitespace().ToFullString());
            }

            return fileNameCode;
        }

        private static ExpressionStatementSyntax CreateFailExpression()
        {
            return SyntaxFactory.ExpressionStatement(
                SyntaxFactory.InvocationExpression(
                        SyntaxFactory.MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            SyntaxFactory.IdentifierName("Assert"),
                            SyntaxFactory.IdentifierName("Fail")))
                    .WithArgumentList(
                        SyntaxFactory.ArgumentList(
                            SyntaxFactory.SingletonSeparatedList<ArgumentSyntax>(
                                SyntaxFactory.Argument(
                                    SyntaxFactory.LiteralExpression(
                                        SyntaxKind.StringLiteralExpression,
                                        SyntaxFactory.Literal("autogenerated")))))));
        }

        private static ClassDeclarationSyntax GenerateClass(ClassInfo classInfo)
        {
            var methods = new List<MethodDeclarationSyntax>();
            foreach (var methodInfo in classInfo.Methods)
            {
                methods.Add(GenerateMethod(methodInfo));
            }

            return SyntaxFactory.ClassDeclaration(classInfo.ClassName)
                .AddMembers(methods.ToArray())
                .AddAttributeLists(SyntaxFactory.AttributeList(SyntaxFactory.AttributeList().Attributes.Add(TestAttribute)));
        }

        private static MethodDeclarationSyntax GenerateMethod(MethodInfo methodInfo)
        {
            List<StatementSyntax> actAssertBody = new List<StatementSyntax>();
            actAssertBody.Add(FailExpression);
            return SyntaxFactory.MethodDeclaration(VoidReturnType, methodInfo.Name)
                .AddModifiers(PublicModifier)
                .WithBody(SyntaxFactory.Block(actAssertBody)); ;
        }
    }
}
